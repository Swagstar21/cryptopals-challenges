"""
Robert Panduru
2018
This is the same approach as the one in Challenge 16 - CBC Bit Flipping.
The bytes generated by the counter can be deduced by injecting a known
plaintext in the encrypter and then observing the corresponding ciphertext
byte. After that, altering the ciphertext in order to decrypt to a specific
plaintext is trivial.
"""

from Crypto.Cipher import AES
from random import randint
from Crypto.Util import Counter

# Random key
def randomKey():
	key = ""
	for i in range(16):
		key += chr(randint(0, 255))
	return key

key = randomKey()
len1 = -1
# Function that generates the cookie and then encypts it
def encrypt(string):
	global key
	global len1
	ctr = Counter.new(nbits=64,  prefix='\x00\x00\x00\x00\x00\x00\x00\x00', initial_value=0, little_endian=True)
	cipher = AES.new(key, AES.MODE_CTR, counter=ctr)
	# Cookie metacharacters are not allowed
	string = string.replace(';', "';'")
	string = string.replace('=', "'='")
	prefix = "comment1=cooking%20MCs;userdata="
	len1 = len(prefix)
	postfix = ";comment2=%20like%20a%20pound%20of%20bacon"
	string = prefix + string + postfix
	return cipher.encrypt(string)

# Function that decrypts the ciphertext and looks for
# admin privileges
def decrypt(string):
	global key
	ctr = Counter.new(nbits=64,  prefix='\x00\x00\x00\x00\x00\x00\x00\x00', initial_value=0, little_endian=True)
	cipher = AES.new(key, AES.MODE_CTR, counter=ctr)
	plaintext = cipher.encrypt(string)
	print(plaintext)
	return ";admin=true;" in plaintext

# We try to obtain the desiredString by tampering the ciphertext
desiredString = ';admin=true;'
plaintext = 'A' * len(desiredString)
# Generate a ciphertext from a known plaintext
ciphertext = encrypt(plaintext)
ciphertext = list(ciphertext)

# We tamper the ciphertext
for i in range(len1, len1 + len(desiredString)):
	ciphertext[i] = chr(ord(desiredString[i - len1]) ^ ord('A') ^ ord(ciphertext[i]))

ciphertext = "".join(ciphertext)

found = decrypt(ciphertext)
print("Is the desired string inside the plaintext?\n%s" % (found))